#![cfg(target_arch="aarch64")]

pub use cortex_a::asm::*;

#[inline(always)]
/// No-op for a repeat of `cycles`
pub fn block(cycles: u32) {
    for _ in 0..cycles { nop() }
}

#[inline(always)]
/// Data Memory Barrier
///
/// The DMB instruction is a memory barrier instruction that ensures
/// the relative order of memory accesses before the barrier with
/// memory accesses after the barrier. The DMB instruction does not
/// ensure the completion of any of the memory accesses for which it
/// ensures relative order.
pub fn dmb() {
    unsafe {
        asm!("dmb sy", options(nomem, nostack));
    }
}

#[inline(always)]
/// Data Synchronization Barrier
///
/// A DSB instruction is a memory barrier that ensures that memory
/// accesses that occur before the DSB instruction have completed
/// before the completion of the DSB instruction. In doing this, it
/// acts as a stronger barrier than a DMB and all ordering that is
/// created by a DMB with specific options is also generated by a DSB
/// with the same options.
pub fn dsb() {
    unsafe {
        asm!("dsb sy", options(nomem, nostack));
    }
}

#[inline(always)]
/// Call `func` until it returns `true`, blocking for `wait` cycles
/// between each try.
pub fn block_until<F>(mut func: F, wait: u32)
where
    F: FnMut() -> bool,
{
    loop {
        if func() {
            return;
        }
        block(wait);
    }
}
